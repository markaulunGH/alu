## 乘除法功能单元

### 概述

出于面积和成本的限制，建议同学们乘除法器各实现两种，可以通过宏定义实现两种乘除法器的切换，一种是简单的移位乘除法器，一种是高性能的乘除法器。高性能是通过面积换时间，而且高性能往往比较负责，建议大家有时间之后才考虑高性能。



### 模块接口建议以下描述实现

除法器模块信号

| 信号       | 方向   | 位宽 | 说明                                                         |
| ---------- | ------ | ---- | ------------------------------------------------------------ |
| clock      | input  | 1    | 时钟信号                                                     |
| reset      | input  | 1    | 复位信号（高有效）                                           |
| dividend   | input  | xlen | 被除数（ xlen 表示要实现的位数，ysyx 中是 64）               |
| divisor    | input  | xlen | 除数                                                         |
| div_valid  | input  | 1    | 为高表示输入的数据有效，如果没有新的除法输入，在除法被接受的下一个周期要置低 |
| divw       | input  | 1    | 为高表示输入的是 32 位乘法                                   |
| div_signed | input  | 1    | 表示是不是有符号除法，为高表示是有符号除法                   |
| flush      | input  | 1    | 为高表示要取消除法（修改一下除法器状态就行）                 |
| div_ready  | output | 1    | 为高表示除法器空闲，可以输入数据                             |
| out_valid  | output | 1    | 为高表示除法器输出了有效结果                                 |
| quotient   | output | xlen | 余数                                                         |
| remainder  | output | xlen | 除数                                                         |

乘法器端口信号

| 信号         | 方向   | 位宽 | 说明                                                         |
| ------------ | ------ | ---- | ------------------------------------------------------------ |
| clock        | input  | 1    | 时钟信号                                                     |
| reset        | input  | 1    | 复位信号（高有效）                                           |
| mul_valid    | input  | 1    | 为高表示输入的数据有效，如果没有新的乘法输入，在乘法被接受的下一个周期要置低 |
| flush        | input  | 1    | 为高表示取消乘法                                             |
| mulw         | input  | 1    | 为高表示是 32 位乘法                                         |
| mul_signed   | input  | 2    | 2’b11（signed x signed）；2’b10（signed x unsigned）；2’b00（unsigned x unsigned）； |
| multiplicand | input  | xlen | 被乘数，xlen 表示乘法器位数                                  |
| multiplier   | input  | xlen | 乘数                                                         |
| mul_ready    | output | 1    | 为高表示乘法器准备好，表示可以输入数据                       |
| out_valid    | output | 1    | 为高表示乘法器输出的结果有效                                 |
| result_hi    | output | xlen | 高 xlen bits 结果                                            |
| result_lo    | output | xlen | 低 xlen bits 结果                                            |

补充说明：一生一芯中 xlen 为 64

### 乘法器的实现

以两个32位数的乘法为例子

#### 一位移位乘法器（移位加）的实现 

将乘法结果设置为零，并将被乘数存入一个 64 bits 寄存器的低 32 bits 中（非 GPR )，将乘数存入一个 32 bits 寄存器中。

在每个时钟周期判断乘数的最低位，如果是 1，将被乘数的加到结果中；如果乘数的最低位是  0，则不需要加入结果中。然后将乘数右移一位，被乘数左移一位。然后进入到下一个时钟周期

执行 32 次步骤，注意这是补码乘法，最高位为1代表的是负数，所以如果一开始的乘数高位是 1 的话，最后一步需要执行补码减法。最后的结果输出的同时，并把结果有效信号拉高。

##### 支持无符号乘法

我们不仅需要支持有符号乘法，还需要支持无符号乘法，那我门应该怎么支持无符号乘法呢？

1. 分别实例化有符号乘法和无符号乘法模块？
2. 改造一下乘法器让其支持有符号和无符号？

**思考**：这里到底两种方法到底**哪种更好**呢？到底是为什么呢？

下面介绍改造乘法器的方法，我认为有两种比较直接的方法。

1. 把是不是有无符号的乘法的信息记录下来，根据这个信息决定最后一步到底是减法还是加法。
2. 把 32bits 数额外扩展一位数，无符号数将这一位置零，有符号数就是根据符号位来补充。这样可以将无符号数简化成有符号数了。

##### 关于测试

强烈建议大家先单独对乘法模块进行随机测试，测试没问题后才将乘法器接入你流水线中。

#### booth两位移位乘法器

Booth乘法器由英国的Booth夫妇提出的，上面的补码乘法器，需要特别地挑出最后一个部分积进行特别处理，有点复杂。而且要计算一个乘法需要 33 个周期（32bits），可以对补码乘法公式进行变换，可以找出更合适硬件实现的乘法。

Booth一位变换，以 8bits 数为例
$$
\quad -y_7*2^7+y_6*2^6+y_5*2^5+y_4*2^4+y_3*2^3+y_2*2^2+y_1*2^1+y_0*2^0\\
  = -y_7*2^7-y_6*2^6-y_5*2^5-y_4*2^4-y_3*2^3-y_2*2^2-y_1*2^1-y_0*2^0\\
  \quad +y_6*2^7+y_5*2^6+y_4*2^5+y_3*2^4+y_2*2^3+y_1*2^2+y_0*2^1\\
  =(y_6-y_7)*2^7+(y_5-y_6)*2^6+(y_4-y_5)*2^5+(y_3-y_4)*2^4+(y_2-y_3)*2^3+(y_1-y_2)*2^2+(y_0-y_1)*2^1+(y_{-1}-y_0)*2^0
$$
其中 $y_{-1}$ 为 0，经过变换后，公式变得更加工整，更加时候硬件的实现，新公式称为 booth 一位乘算法。

booth一位乘法需要根据乘数的最低两位才能确定如何将被乘数加到结果中，根据公式可以得出如下规则。

（注意：需要在乘数最低位（最右侧）添零）

| $y_i$ | $y_{i-1}$ | 操作                     |
| ----- | --------- | ------------------------ |
| 0     | 0         | 不需要加(+0)             |
| 0     | 1         | 补码加X（$+[X]_补\quad$) |
| 1     | 0         | 补码减X（$-[X]_补\quad$) |
| 1     | 1         | 不需要加（+0）           |

Booth 一位乘法的补码加法器，面积较大，电路延迟较长，限制了硬件乘法器的速度，对补码乘法公式进行变换，得到如下的 booth 两位乘算法（以 8bits 数为例）。
$$
\quad -y_7*2^7+y_6*2^6+y_5*2^5+y_4*2^4+y_3*2^3+y_2*2^2+y_1*2^1+y_0*2^0\\
  = -2*y_7*2^6+y_6*2^6+y_5*2^6-2*y_5*2^4+y_4*2^4+y_3*2^4\\
\quad  -2*y_3*y2+y_2*2^2+y_1*2^2-2*y_1*2^0+y_0*2^0+y_{-1}*2^0 \\
  =(y_5+y_6-2*y_7)*2^6+(y_3+y_4-2*y_5)*2^4+(y_1+y_2-2*y_3)*2^2+(y_{-1}+y_0-2*y_1)*2^0
$$
根据 Booth 两位乘算法，需要**每次扫描 3 位**的乘数，并在每次累加完成后，将被乘数和乘数移 2 位。根据算法公式，可以推导出操作的方式。注意被扫描的 3 位是当前操作阶数  i  加 上其左右各 1 位。 (举例子，如果是 8 位的数字，起始位为 0 位。那么 i 就为0，2，4，6)

#### booth两位运算规则

| $y_{i+1}$ | $y_i$ | $y_{i-1}$ | 操作                          |
| --------- | ----- | --------- | ----------------------------- |
| 0         | 0     | 0         | 不需要加（+0）                |
| 0         | 0     | 1         | 补码加X（$+[X]_补\quad$)      |
| 0         | 1     | 0         | 补码加X（$+[X]_补\quad$)      |
| 0         | 1     | 1         | 补码加2X（$+[X]_补\quad$左移) |
| 1         | 0     | 0         | 补码减2X（$-[X]_补\quad$左移) |
| 1         | 0     | 1         | 补码减X（$-[X]_补\quad$)      |
| 1         | 1     | 0         | 补码减X（$-[X]_补\quad$)      |
| 1         | 1     | 1         | 不需要加（+0）                |

 Booth 乘法的核心是部分积的生成，共需要生成 N/2 个部分积。每个部分积与 [X]补 相关，总共 有 ‑X、‑2X、+X、+2X和0五种可能，而其中减去[X]补 的操作，可以视作加上按位取反的[X]补 再末位加 1。  

假设$[X]_补\quad$的二进制格式可以写成$x_7x_6x_5x_4x_3x_2x_1x_0$假设部分积P等于$p_7p_6p_5p_4p_3p_2p_1p_0+c\quad$可以有如下情况

|         |            | 选择      |
| ------- | ---------- | --------- |
| $p_i$== | ~$x_i$     | 选择  -x  |
|         | ~$x_{i-1}$ | 选择  -2x |
|         | $x_i$      | 选择  +x  |
|         | ~$x_{i-1}$ | 选择  +2x |
|         | 0          | 选择  0   |

当部分积的选择为 2X 时，可以视作 X 输入左移 1 位，此时 $p_i$就与 $x_{i-1}$ 相等。如果部分积的选择 是 ‑X  或者 ‑2X，则此处对  $x_i$  或者  $x_{i-1}$ 取反，并设置最后的末位进位  c  为  1。  

#### 结果选择逻辑

根据卡诺图分析可以得到每一位 $p_i$ 的表达式
$$
p_i=\sim (\sim(S_{-x}\& \sim x_i) \& \sim (S_{-2x} \& \sim x_{i-1}) \& \sim (S_{+x} \& x_i) \& \sim (S_{2x} \& x_{i-1}))
$$

```verilog
assign p = ~(~(sel_negative & ~x) & ~(sel_double_negative & ~x_sub) 
           & ~(sel_positive & x ) & ~(sel_double_positive &  x_sub));
```

#### booth选择信号的生成

```verilog
///y+1,y,y-1///
wire y_add,y,y_sub;
wire sel_negative,sel_double_negative,sel_positive,sel_double_positive;

assign {y_add,y,y_sub} = src;

assign sel_negative =  y_add & (y & ~y_sub | ~y & y_sub);
assign sel_positive = ~y_add & (y & ~y_sub | ~y & y_sub);
assign sel_double_negative =  y_add & ~y & ~y_sub;
assign sel_double_positive = ~y_add &  y &  y_sub;
```

#### Booth部分积生成模块

建议大家把上面的两个部分别都封装成一个模块，然后将部分积生成模块中将上面的两个模块组合起来就好了，最后再把部分积模块也封装成一个模块。这样你就有了一个部分积生成模块。

#### 移位加实现booth两位乘法（以32bits数为例）

1. 乘法开始的时候需要在乘数的最右边补一个零，把结果全部置零。
2. 将乘数的最低 3bits 和被乘数的 64bits 输入到部分积生成模块，把部分积生成模块生成的数与结果用 64bits 加法器相加，并把和暂存到结果寄存器中，并把乘数右移两位，把被乘数左移两位。
3. 重复上面的步骤，直至被乘数的高 32bits 为零。
4. 同时支持无符号和有符号乘法

由于两位 booth 每次需要扫描三位乘数，此时不能只扩展一位符号位，只能扩展两位符号位。

#### 华莱士树+booth

即使采用了 Booth 两位乘法，使用移位加策略来完成一个 64 位乘法，也需要 32 个时钟周期，并且还不支持流水。由于乘法具有完整的交换律，可以通过面积换时间的方式，将各个部分积并行的加在一起，而非串行迭代累加。

##### 我们目前只差两个关键模块（以32bits乘法为例）。

**第一个switch模块**

其作用类似于矩阵的转置，在 32bits（扩展成 34bits )乘法中是将17个68bits部分积转换成 68个17bits 数，其实这个模块就是纯连线没有额外的元件。

**第二个模块是17bits华莱士树。**

17bits华莱士树共有6层，使用了15个全加器。

```verilog
//一位全加器
module csa(
  input [2:0] in,
  output cout,s

);
wire a,b,cin;
assign a=in[2];
assign b=in[1];
assign cin=in[0];
assign s = a ^ b ^ cin;
assign cout = a & b | b & cin | a & cin;
endmodule
```

| 信号       | 方向   | 描述                                                         |
| ---------- | ------ | ------------------------------------------------------------ |
| src_in     | input  | 输入的 17bits 数据                                           |
| cin        | input  | 来自右边华莱士树的进位输入，最右边的华莱士树的 cin 是来自 switch 模块 |
| cout_group | output | 输入到左边的华莱士树的进位输出，最左边的华莱士树的忽略即可   |
| cout       | output | 输出到加法器的 src1                                          |
| s          | output | 输出到加法器的 src2                                          |



```verilog
module walloc_17bits(
    input [16:0] src_in,
    input [13:0]  cin,
    output [13:0] cout_group,
    output      cout,s
);
wire [13:0] c;
///////////////first////////////////
wire [4:0] first_s;
csa csa0 (.in (src_in[16:14]), .cout (c[4]), .s (first_s[4]) );
csa csa1 (.in (src_in[13:11]), .cout (c[3]), .s (first_s[3]) );
csa csa2 (.in (src_in[10:08]), .cout (c[2]), .s (first_s[2]) );
csa csa3 (.in (src_in[07:05]), .cout (c[1]), .s (first_s[1]) );
csa csa4 (.in (src_in[04:02]), .cout (c[0]), .s (first_s[0]) );

///////////////secnod//////////////
wire [3:0] secnod_s;
csa csa5 (.in ({first_s[4:2]}             ), .cout (c[8]), .s (secnod_s[3]));
csa csa6 (.in ({first_s[1:0],src_in[1]}   ), .cout (c[7]), .s (secnod_s[2]));
csa csa7 (.in ({src_in[0],cin[4:3]}       ), .cout (c[6]), .s (secnod_s[1]));
csa csa8 (.in ({cin[2:0]}                 ), .cout (c[5]), .s (secnod_s[0]));

//////////////thrid////////////////
wire [1:0] thrid_s;
csa csa9 (.in (secnod_s[3:1]          ), .cout (c[10]), .s (thrid_s[1]));
csa csaA (.in ({secnod_s[0],cin[6:5]} ), .cout (c[09]), .s (thrid_s[0]));

//////////////fourth////////////////
wire [1:0] fourth_s;

csa csaB (.in ({thrid_s[1:0],cin[10]} ),  .cout (c[12]), .s (fourth_s[1]));
csa csaC (.in ({cin[9:7]             }),  .cout (c[11]), .s (fourth_s[0]));

//////////////fifth/////////////////
wire fifth_s;

csa csaD (.in ({fourth_s[1:0],cin[11]}),  .cout (c[13]), .s (fifth_s));

///////////////sixth///////////////
csa csaE (.in ({fifth_s,cin[13:12]}   ),  .cout (cout),  .s  (s));

///////////////output///////////////
assign cout_group = c;
endmodule
```

注意：最左边的华莱士树的 cout 不接入到最后的加法器的src1中，src1 的最低位来自 switch 的输出，然后剩下的高67bits，来自除了最左边华莱士树的的cout.

下面是 32 bits walloc X booth的示意图



### 除法实现

未完待续