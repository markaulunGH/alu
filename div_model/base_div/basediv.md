# 迭代除法器

除法器依据是否将源操作数转换为绝对值分成绝对值除法器和补码除法器。绝对值除法器最后得到的是商和余数的绝对值，最后需要计算一下商和余数的补码；补码除法器最后的结果是补码，但是存在多减多除的情况，需要对余数进行调整。

简单的迭代除法是试商法。 依据迭代过程中，在不够减时（商为 0），是否恢复余数分为：恢复余数法（循环减法），不恢复余数法（加减交替）。 

## 迭代主要步骤和操作

本除法器为1为恢复余数绝对值迭代除法器。运算主要有三大步。

### ( 一  ).根据被除数和除数确定商和余数的符号，并计算除数和被除数的绝对值



| 被除数 | 除数 | 商   | 余数 |
| :----: | ---- | ---- | ---- |
|   正   | 正   | 正   | 正   |
|   正   | 负   | 负   | 正   |
|   负   | 正   | 负   | 负   |
|   负   | 负   | 正   | 负   |

对于无符号数，计算机存的数就是其源码，因此绝对值不需要变换。对于有符号正数，存的是补码但是其补码等于源码，对于有符号数负数，存的是补码，对齐取反加一后可得到绝对值。总结：只有有符号负数需要调整。

### (  二  ).迭代运算得到商和余数的绝对值

```verilog
//用于保存除数和被除数是否为有符号负数（为1表示为有符号负数）
reg divisor_s,dividend_s;
always @(posedge clk) begin
    if (reset) begin
        divisor_s <= 1'b0;
        dividend_s <= 1'b0;        
    end
    else if (ready_to_doing) begin
        divisor_s <= div_signed & y[31];
        dividend_s <= div_signed & x[31];
    end    
end
```

1. **将被除数前面补32个0， 记为A[63:0]，记除数为B[31:0]，得到的商记为S[31:0]， 余数即为 R[31:0] .**
2.  **第一次迭代，取 A 的高 33 位，即 A[63:31]，与 B 高位补 0 的结果{1’b0,B[31:0]}做减法：如 果结果为负数，则商的相应位(S[31])为 0，被除数保持不变；如果结果为正数，则商的相应 位记为 1，将被除数的相应位(A[63:31])更新为减法的结果。**

3.  **随后进行第二次迭代，此时就需要取 A[62:30]与{1’b0,B[31:0]}作减法，依据结果更新 S[30]， 并更新 A[62:30]。** 

4.  **依此类推，直到算完第 0 位。** 


```verilog
dividend <= sub_cout ? {sub_result[31:0],dividend[30:0],1'b0} : {dividend[62:0],1'b0};
/*例子在实现的过程中与上面的表述不太一样，在第二小点在更新被除数后将被除数整体左移了一位。这样可以使得第三小点的时候仍然可以取被除数的[63:31]进行计算，同样的在更新商的时候也采用了同样的处理。*/
```

### ( 三 ）.调整最终商和余数

```verilog
/*remain_correct和qutient是取反加1后的值*/
//need_correct表示需不需要取反加1
//这里的x_adder_result与一开始求绝对值的时候是共用一个
//在上面迭代的时候使用了一个33bits的加法器，为了节省资源可以去掉一个32bits的加法器，
//然后使用一个33bits替换掉，这样就只需要一个32bits和33bits加法器了
//为了方便阅读，还是用了两个32bits和一个33bits加法器
assign remain_correct  = x_adder_result;
assign qutient_correct = y_adder_result;
assign qutient_need_correct = ~dividend_s & divisor_s | dividend_s & ~divisor_s;
assign remain_need_correct  = dividend_s;

```

## 模块信号

| 信号       | 位宽 | 方向   | 功能                                   |
| ---------- | ---- | ------ | -------------------------------------- |
| clk        | 1    | input  | 时钟信号                               |
| reset      | 1    | input  | 复位信号，高有效                       |
| x          | 32   | input  | 被除数                                 |
| y          | 32   | input  | 除数                                   |
| in_valid   | 1    | input  | 除法运算信号，**无新除法需要置零**     |
| div_signed | 1    | input  | 是否为有符号除法                       |
| in_ready   | 1    | output | 除法器是否准备好                       |
| out_valid  | 1    | output | 除法器输出的结果有效信号，只会维持一拍 |
| s          | 32   | output | 商                                     |
| r          | 32   | output | 余数                                   |

只有in_valid和in_ready同时为1才说明除法接收了数据

## 进一步优化

这部分建议学有余力的同学考虑，如果是第一次建议先把处理器核先搭完

改成二位试商，代价是时序变差，消耗的资源更多

迭代除法容易出现一堆零，可以考虑提前开始或者提前结束

更多。。。





此文章参考《CPU设计实战》第五章