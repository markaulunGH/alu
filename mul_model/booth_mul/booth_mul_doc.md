关于超前进位加法器，最后的结果不是在顶层输出的，最后的结果是在第一层输出的，就是相当于去绕了一圈然后原路返回。

Booth的补码乘法器（以8位为例子）

Booth一位变换
$$
\quad -y_7*2^7+y_6*2^6+y_5*2^5+y_4*2^4+y_3*2^3+y_2*2^2+y_1*2^1+y_0*2^0\\
  = -y_7*2^7-y_6*2^6-y_5*2^5-y_4*2^4-y_3*2^3-y_2*2^2-y_1*2^1-y_0*2^0\\
  \quad +y_6*2^7+y_5*2^6+y_4*2^5+y_3*2^4+y_2*2^3+y_1*2^2+y_0*2^1\\
  =(y_6-y_7)*2^7+(y_5-y_6)*2^6+(y_4-y_5)*2^5+(y_3-y_4)*2^4+(y_2-y_3)*2^3+(y_1-y_2)*2^2+(y_0-y_1)*2^1+(y_{-1}-y_0)*2^0
$$
其中的$y_{-1}$取值为0， 经过变换，公式变得更加规整，不再需要专门对最后一次部分积采用补码 减法，更适合硬件实现。这个新公式被称为 Booth 一位乘算法 。

 为了实现Booth一位乘算法，需要根据乘数的最末两位来确定如何将被乘数累加到结果中，再 将乘数和被乘数移一位。根据算法公式，很容易得出它的规则 

| $y_i$ | $y_{i-1}$ | 操作                     |
| ----- | --------- | ------------------------ |
| 0     | 0         | 不需要加(+0)             |
| 0     | 1         | 补码加X（$+[X]_补\quad$) |
| 1     | 0         | 补码减X（$-[X]_补\quad$) |
| 1     | 1         | 不需要加（+0）           |

 注意算法开始时，要**隐含地在乘数最右侧补**一个 $y_{-1}$的值（补0）。(就是弄得上下对齐)

两位Booth乘法

 补码加法器面积大、电路延迟长，限制了硬件乘法器的计算速度，因此重新对补码乘法公式进行 变换，得到 Booth 两位乘算法 
$$
\quad -y_7*2^7+y_6*2^6+y_5*2^5+y_4*2^4+y_3*2^3+y_2*2^2+y_1*2^1+y_0*2^0\\
  = -2*y_7*2^6+y_6*2^6+y_5*2^6-2*y_5*2^4+y_4*2^4+y_3*2^4\\
\quad  -2*y_3*y2+y_2*2^2+y_1*2^2-2*y_1*2^0+y_0*2^0+y_{-1}*2^0 \\
  =(y_5+y_6-2*y_7)*2^6+(y_3+y_4-2*y_5)*2^4+(y_1+y_2-2*y_3)*2^2+(y_{-1}+y_0-2*y_1)*2^0
$$
 根据 Booth 两位乘算法，需要**每次扫描 3 位**的乘数，并在每次累加完成后，将被乘数和乘数移 2 位。根据算法公式，可以推导出操作的方式。注意被扫描的 3 位是当前操作阶数 i 加 上其左右各 1 位。 (举例子，如果是8位的数字，起始位为0位。那么i就为0，2，4，6)

booth两位运算规则

| $y_{i+1}$ | $y_i$ | $y_{i-1}$ | 操作                          |
| --------- | ----- | --------- | ----------------------------- |
| 0         | 0     | 0         | 不需要加（+0）                |
| 0         | 0     | 1         | 补码加X（$+[X]_补\quad$)      |
| 0         | 1     | 0         | 补码加X（$+[X]_补\quad$)      |
| 0         | 1     | 1         | 补码加2X（$+[X]_补\quad$左移) |
| 1         | 0     | 0         | 补码减2X（$-[X]_补\quad$左移) |
| 1         | 0     | 1         | 补码减X（$-[X]_补\quad$)      |
| 1         | 1     | 0         | 补码减X（$-[X]_补\quad$)      |
| 1         | 1     | 1         | 不需要加（+0）                |

 如果使用 Booth 两位乘算法，计算 N 位的补码乘法时，只需要 N/2‑1 次加法，如果使用移位加 策略，则需要 N/2 个时钟周期来完成计算。 

 Booth 乘法的核心是部分积的生成，共需要生成 N/2 个部分积。每个部分积与 [X]补 相关，总共 有‑X、‑2X、+X、+2X和0五种可能，而其中减去[X]补 的操作，可以视作加上按位取反的[X]补 再末位加1。  

